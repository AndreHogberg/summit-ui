@namespace SummitUI
@using System.Linq.Expressions
@using Microsoft.AspNetCore.Components.Forms

<CascadingValue Value="_context" IsFixed="false">
    <button type="button"
            role="switch"
            aria-checked="@(IsChecked ? "true" : "false")"
            data-state="@(IsChecked ? "checked" : "unchecked")"
            disabled="@Disabled"
            aria-disabled="@(Disabled ? "true" : null)"
            data-disabled="@(Disabled ? "" : null)"
            @onclick="HandleClick"
            @attributes="AdditionalAttributes">
        @ChildContent
    </button>
    @if (!string.IsNullOrEmpty(Name))
    {
        <input type="hidden"
               name="@Name"
               value="@(IsChecked ? (Value ?? "on") : "")"
               disabled="@Disabled"
               required="@Required" />
    }
</CascadingValue>

@code {
    /// <summary>
    /// The controlled checked state. When provided, the component operates in controlled mode.
    /// </summary>
    [Parameter] public bool? Checked { get; set; }

    /// <summary>
    /// The default checked state for uncontrolled mode.
    /// </summary>
    [Parameter] public bool DefaultChecked { get; set; }

    /// <summary>
    /// Callback when the checked state changes. Supports two-way binding with @bind-Checked.
    /// </summary>
    [Parameter] public EventCallback<bool> CheckedChanged { get; set; }

    /// <summary>
    /// Expression for the checked value, used for EditForm binding and validation.
    /// This is automatically provided when using @bind-Checked.
    /// </summary>
    [Parameter] public Expression<Func<bool>>? CheckedExpression { get; set; }

    /// <summary>
    /// Cascading EditContext from an EditForm parent.
    /// </summary>
    [CascadingParameter] private EditContext? EditContext { get; set; }

    [Parameter] public bool Disabled { get; set; }
    [Parameter] public bool Required { get; set; }
    [Parameter] public string? Name { get; set; }
    [Parameter] public string? Value { get; set; }
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter(CaptureUnmatchedValues = true)] public IDictionary<string, object>? AdditionalAttributes { get; set; }

    private bool _internalChecked;
    private SwitchContext _context = new();
    private FieldIdentifier? _fieldIdentifier;

    private bool IsControlled => Checked.HasValue;
    private bool IsChecked => IsControlled ? (Checked ?? false) : _internalChecked;

    protected override void OnInitialized()
    {
        _internalChecked = DefaultChecked;
        UpdateContext();
    }

    protected override void OnParametersSet()
    {
        // Set up EditContext field identifier for validation (needs to happen after cascading parameters are set)
        if (!_fieldIdentifier.HasValue && EditContext is not null && CheckedExpression is not null)
        {
            _fieldIdentifier = FieldIdentifier.Create(CheckedExpression);
        }

        UpdateContext();
    }

    private void UpdateContext()
    {
        _context = new SwitchContext
        {
            IsChecked = IsChecked
        };
    }

    private async Task HandleClick()
    {
        if (Disabled) return;

        var newChecked = !IsChecked;

        if (!IsControlled)
        {
            _internalChecked = newChecked;
        }

        UpdateContext();
        await CheckedChanged.InvokeAsync(newChecked);

        // Notify EditContext of field change for validation
        if (EditContext is not null && _fieldIdentifier.HasValue)
        {
            EditContext.NotifyFieldChanged(_fieldIdentifier.Value);
        }
    }
}
